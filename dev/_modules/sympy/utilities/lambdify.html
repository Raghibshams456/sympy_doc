
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>sympy.utilities.lambdify &#8212; SymPy 1.5.dev documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/_modules/sympy/utilities/lambdify.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.5.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.utilities.lambdify</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides convenient functions to transform sympy expressions to</span>
<span class="sd">lambda functions which can be used to calculate numerical values very fast.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">keyword</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">linecache</span>

<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="k">import</span> <span class="p">(</span><span class="n">exec_</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span>
    <span class="n">NotIterable</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">builtins</span><span class="p">,</span> <span class="n">PY3</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="k">import</span> <span class="n">filldedent</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.decorator</span> <span class="k">import</span> <span class="n">doctest_depends_on</span>

<span class="n">__doctest_requires__</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;lambdify&#39;</span><span class="p">,):</span> <span class="p">[</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">]}</span>

<span class="c1"># Default namespaces, letting us define translations that can&#39;t be defined</span>
<span class="c1"># by simple variable maps, like I =&gt; 1j</span>
<span class="n">MATH_DEFAULT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">MPMATH_DEFAULT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">NUMPY_DEFAULT</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="n">j</span><span class="p">}</span>
<span class="n">SCIPY_DEFAULT</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="n">j</span><span class="p">}</span>
<span class="n">TENSORFLOW_DEFAULT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">SYMPY_DEFAULT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">NUMEXPR_DEFAULT</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># These are the namespaces the lambda functions will use.</span>
<span class="c1"># These are separate from the names above because they are modified</span>
<span class="c1"># throughout this file, whereas the defaults should remain unmodified.</span>

<span class="n">MATH</span> <span class="o">=</span> <span class="n">MATH_DEFAULT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">MPMATH</span> <span class="o">=</span> <span class="n">MPMATH_DEFAULT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">NUMPY</span> <span class="o">=</span> <span class="n">NUMPY_DEFAULT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">SCIPY</span> <span class="o">=</span> <span class="n">SCIPY_DEFAULT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">TENSORFLOW</span> <span class="o">=</span> <span class="n">TENSORFLOW_DEFAULT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">SYMPY</span> <span class="o">=</span> <span class="n">SYMPY_DEFAULT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">NUMEXPR</span> <span class="o">=</span> <span class="n">NUMEXPR_DEFAULT</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


<span class="c1"># Mappings between sympy and other modules function names.</span>
<span class="n">MATH_TRANSLATIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;ceiling&quot;</span><span class="p">:</span> <span class="s2">&quot;ceil&quot;</span><span class="p">,</span>
    <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ln&quot;</span><span class="p">:</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># NOTE: This dictionary is reused in Function._eval_evalf to allow subclasses</span>
<span class="c1"># of Function to automatically evalf.</span>
<span class="n">MPMATH_TRANSLATIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;Abs&quot;</span><span class="p">:</span> <span class="s2">&quot;fabs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;elliptic_k&quot;</span><span class="p">:</span> <span class="s2">&quot;ellipk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;elliptic_f&quot;</span><span class="p">:</span> <span class="s2">&quot;ellipf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;elliptic_e&quot;</span><span class="p">:</span> <span class="s2">&quot;ellipe&quot;</span><span class="p">,</span>
    <span class="s2">&quot;elliptic_pi&quot;</span><span class="p">:</span> <span class="s2">&quot;ellippi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ceiling&quot;</span><span class="p">:</span> <span class="s2">&quot;ceil&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chebyshevt&quot;</span><span class="p">:</span> <span class="s2">&quot;chebyt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;chebyshevu&quot;</span><span class="p">:</span> <span class="s2">&quot;chebyu&quot;</span><span class="p">,</span>
    <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span>
    <span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="s2">&quot;j&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ln&quot;</span><span class="p">:</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span>
    <span class="c1">#&quot;lowergamma&quot;:&quot;lower_gamma&quot;,</span>
    <span class="s2">&quot;oo&quot;</span><span class="p">:</span> <span class="s2">&quot;inf&quot;</span><span class="p">,</span>
    <span class="c1">#&quot;uppergamma&quot;:&quot;upper_gamma&quot;,</span>
    <span class="s2">&quot;LambertW&quot;</span><span class="p">:</span> <span class="s2">&quot;lambertw&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MutableDenseMatrix&quot;</span><span class="p">:</span> <span class="s2">&quot;matrix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ImmutableDenseMatrix&quot;</span><span class="p">:</span> <span class="s2">&quot;matrix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;conjugate&quot;</span><span class="p">:</span> <span class="s2">&quot;conj&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dirichlet_eta&quot;</span><span class="p">:</span> <span class="s2">&quot;altzeta&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ei&quot;</span><span class="p">:</span> <span class="s2">&quot;ei&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Shi&quot;</span><span class="p">:</span> <span class="s2">&quot;shi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Chi&quot;</span><span class="p">:</span> <span class="s2">&quot;chi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Si&quot;</span><span class="p">:</span> <span class="s2">&quot;si&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ci&quot;</span><span class="p">:</span> <span class="s2">&quot;ci&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RisingFactorial&quot;</span><span class="p">:</span> <span class="s2">&quot;rf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FallingFactorial&quot;</span><span class="p">:</span> <span class="s2">&quot;ff&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">NUMPY_TRANSLATIONS</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">SCIPY_TRANSLATIONS</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">TENSORFLOW_TRANSLATIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;Abs&quot;</span><span class="p">:</span> <span class="s2">&quot;abs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ceiling&quot;</span><span class="p">:</span> <span class="s2">&quot;ceil&quot;</span><span class="p">,</span>
    <span class="s2">&quot;im&quot;</span><span class="p">:</span> <span class="s2">&quot;imag&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ln&quot;</span><span class="p">:</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Mod&quot;</span><span class="p">:</span> <span class="s2">&quot;mod&quot;</span><span class="p">,</span>
    <span class="s2">&quot;conjugate&quot;</span><span class="p">:</span> <span class="s2">&quot;conj&quot;</span><span class="p">,</span>
    <span class="s2">&quot;re&quot;</span><span class="p">:</span> <span class="s2">&quot;real&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">NUMEXPR_TRANSLATIONS</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># Available modules:</span>
<span class="n">MODULES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;math&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">MATH</span><span class="p">,</span> <span class="n">MATH_DEFAULT</span><span class="p">,</span> <span class="n">MATH_TRANSLATIONS</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;from math import *&quot;</span><span class="p">,)),</span>
    <span class="s2">&quot;mpmath&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">MPMATH</span><span class="p">,</span> <span class="n">MPMATH_DEFAULT</span><span class="p">,</span> <span class="n">MPMATH_TRANSLATIONS</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;from mpmath import *&quot;</span><span class="p">,)),</span>
    <span class="s2">&quot;numpy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">NUMPY</span><span class="p">,</span> <span class="n">NUMPY_DEFAULT</span><span class="p">,</span> <span class="n">NUMPY_TRANSLATIONS</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;import numpy; from numpy import *; from numpy.linalg import *&quot;</span><span class="p">,)),</span>
    <span class="s2">&quot;scipy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">SCIPY</span><span class="p">,</span> <span class="n">SCIPY_DEFAULT</span><span class="p">,</span> <span class="n">SCIPY_TRANSLATIONS</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;import numpy; import scipy; from scipy import *; from scipy.special import *&quot;</span><span class="p">,)),</span>
    <span class="s2">&quot;tensorflow&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">TENSORFLOW</span><span class="p">,</span> <span class="n">TENSORFLOW_DEFAULT</span><span class="p">,</span> <span class="n">TENSORFLOW_TRANSLATIONS</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;from tensorflow import *&quot;</span><span class="p">,)),</span>
    <span class="s2">&quot;sympy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">SYMPY</span><span class="p">,</span> <span class="n">SYMPY_DEFAULT</span><span class="p">,</span> <span class="p">{},</span> <span class="p">(</span>
        <span class="s2">&quot;from sympy.functions import *&quot;</span><span class="p">,</span>
        <span class="s2">&quot;from sympy.matrices import *&quot;</span><span class="p">,</span>
        <span class="s2">&quot;from sympy import Integral, pi, oo, nan, zoo, E, I&quot;</span><span class="p">,)),</span>
    <span class="s2">&quot;numexpr&quot;</span> <span class="p">:</span> <span class="p">(</span><span class="n">NUMEXPR</span><span class="p">,</span> <span class="n">NUMEXPR_DEFAULT</span><span class="p">,</span> <span class="n">NUMEXPR_TRANSLATIONS</span><span class="p">,</span>
                 <span class="p">(</span><span class="s2">&quot;import_module(&#39;numexpr&#39;)&quot;</span><span class="p">,</span> <span class="p">)),</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_import</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">reload</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a global translation dictionary for module.</span>

<span class="sd">    The argument module has to be one of the following strings: &quot;math&quot;,</span>
<span class="sd">    &quot;mpmath&quot;, &quot;numpy&quot;, &quot;sympy&quot;, &quot;tensorflow&quot;.</span>
<span class="sd">    These dictionaries map names of python functions to their equivalent in</span>
<span class="sd">    other modules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Required despite static analysis claiming it is not used</span>
    <span class="kn">from</span> <span class="nn">sympy.external</span> <span class="k">import</span> <span class="n">import_module</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">namespace</span><span class="p">,</span> <span class="n">namespace_default</span><span class="p">,</span> <span class="n">translations</span><span class="p">,</span> <span class="n">import_commands</span> <span class="o">=</span> <span class="n">MODULES</span><span class="p">[</span>
            <span class="n">module</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
            <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; module can&#39;t be used for lambdification&quot;</span> <span class="o">%</span> <span class="n">module</span><span class="p">)</span>

    <span class="c1"># Clear namespace or exit</span>
    <span class="k">if</span> <span class="n">namespace</span> <span class="o">!=</span> <span class="n">namespace_default</span><span class="p">:</span>
        <span class="c1"># The namespace was already generated, don&#39;t do it again if not forced.</span>
        <span class="k">if</span> <span class="n">reload</span><span class="p">:</span>
            <span class="n">namespace</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">namespace_default</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>

    <span class="k">for</span> <span class="n">import_command</span> <span class="ow">in</span> <span class="n">import_commands</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">import_command</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;import_module&#39;</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">import_command</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">exec_</span><span class="p">(</span><span class="n">import_command</span><span class="p">,</span> <span class="p">{},</span> <span class="n">namespace</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;can&#39;t import &#39;</span><span class="si">%s</span><span class="s2">&#39; with &#39;</span><span class="si">%s</span><span class="s2">&#39; command&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">import_command</span><span class="p">))</span>

    <span class="c1"># Add translated names to namespace</span>
    <span class="k">for</span> <span class="n">sympyname</span><span class="p">,</span> <span class="n">translation</span> <span class="ow">in</span> <span class="n">translations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">namespace</span><span class="p">[</span><span class="n">sympyname</span><span class="p">]</span> <span class="o">=</span> <span class="n">namespace</span><span class="p">[</span><span class="n">translation</span><span class="p">]</span>

    <span class="c1"># For computing the modulus of a sympy expression we use the builtin abs</span>
    <span class="c1"># function, instead of the previously used fabs function for all</span>
    <span class="c1"># translation modules. This is because the fabs function in the math</span>
    <span class="c1"># module does not accept complex valued arguments. (see issue 9474). The</span>
    <span class="c1"># only exception, where we don&#39;t use the builtin abs function is the</span>
    <span class="c1"># mpmath translation module, because mpmath.fabs returns mpf objects in</span>
    <span class="c1"># contrast to abs().</span>
    <span class="k">if</span> <span class="s1">&#39;Abs&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">:</span>
        <span class="n">namespace</span><span class="p">[</span><span class="s1">&#39;Abs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span>


<span class="c1"># Used for dynamically generated filenames that are inserted into the</span>
<span class="c1"># linecache.</span>
<span class="n">_lambdify_generated_counter</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="lambdify"><a class="viewcode-back" href="../../../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify">[docs]</a><span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">python_version</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">lambdify</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">printer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_imps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">dummify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translates a SymPy expression into an equivalent numeric function</span>

<span class="sd">    For example, to convert the SymPy expression ``sin(x) + cos(x)`` to an</span>
<span class="sd">    equivalent NumPy function that numerically evaluates it:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sin, cos, symbols, lambdify</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; x = symbols(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; expr = sin(x) + cos(x)</span>
<span class="sd">    &gt;&gt;&gt; expr</span>
<span class="sd">    sin(x) + cos(x)</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify(x, expr, &#39;numpy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; f(a)</span>
<span class="sd">    [1.38177329 0.49315059]</span>

<span class="sd">    The primary purpose of this function is to provide a bridge from SymPy</span>
<span class="sd">    expressions to numerical libraries such as NumPy, SciPy, NumExpr, mpmath,</span>
<span class="sd">    and tensorflow. In general, SymPy functions do not work with objects from</span>
<span class="sd">    other libraries, such as NumPy arrays, and functions from numeric</span>
<span class="sd">    libraries like NumPy or mpmath do not work on SymPy expressions.</span>
<span class="sd">    ``lambdify`` bridges the two by converting a SymPy expression to an</span>
<span class="sd">    equivalent numeric function.</span>

<span class="sd">    The basic workflow with ``lambdify`` is to first create a SymPy expression</span>
<span class="sd">    representing whatever mathematical function you wish to evaluate. This</span>
<span class="sd">    should be done using only SymPy functions and expressions. Then, use</span>
<span class="sd">    ``lambdify`` to convert this to an equivalent function for numerical</span>
<span class="sd">    evaluation. For instance, above we created ``expr`` using the SymPy symbol</span>
<span class="sd">    ``x`` and SymPy functions ``sin`` and ``cos``, then converted it to an</span>
<span class="sd">    equivalent NumPy function ``f``, and called it on a NumPy array ``a``.</span>

<span class="sd">    .. warning::</span>
<span class="sd">       This function uses ``exec``, and thus shouldn&#39;t be used on unsanitized</span>
<span class="sd">       input.</span>

<span class="sd">    Arguments</span>
<span class="sd">    =========</span>

<span class="sd">    The first argument of ``lambdify`` is a variable or list of variables in</span>
<span class="sd">    the expression. Variable lists may be nested. Variables can be Symbols,</span>
<span class="sd">    undefined functions, or matrix symbols. The order and nesting of the</span>
<span class="sd">    variables corresponds to the order and nesting of the parameters passed to</span>
<span class="sd">    the lambdified function. For instance,</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify([x, (y, z)], x + y + z)</span>
<span class="sd">    &gt;&gt;&gt; f(1, (2, 3))</span>
<span class="sd">    6</span>

<span class="sd">    The second argument of ``lambdify`` is the expression, list of</span>
<span class="sd">    expressions, or matrix to be evaluated. Lists may be nested. If the</span>
<span class="sd">    expression is a list, the output will also be a list.</span>

<span class="sd">    &gt;&gt;&gt; f = lambdify(x, [x, [x + 1, x + 2]])</span>
<span class="sd">    &gt;&gt;&gt; f(1)</span>
<span class="sd">    [1, [2, 3]]</span>

<span class="sd">    If it is a matrix, an array will be returned (for the NumPy module).</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify(x, Matrix([x, x + 1]))</span>
<span class="sd">    &gt;&gt;&gt; f(1)</span>
<span class="sd">    [[1]</span>
<span class="sd">     [2]]</span>

<span class="sd">    Note that the argument order here, variables then expression, is used to</span>
<span class="sd">    emulate the Python ``lambda`` keyword. ``lambdify(x, expr)`` works</span>
<span class="sd">    (roughly) like ``lambda x: expr`` (see :ref:`lambdify-how-it-works` below).</span>

<span class="sd">    The third argument, ``modules`` is optional. If not specified, ``modules``</span>
<span class="sd">    defaults to ``[&quot;scipy&quot;, &quot;numpy&quot;]`` if SciPy is installed, ``[&quot;numpy&quot;]`` if</span>
<span class="sd">    only NumPy is installed, and ``[&quot;math&quot;, &quot;mpmath&quot;, &quot;sympy&quot;]`` if neither is</span>
<span class="sd">    installed. That is, SymPy functions are replaced as far as possible by</span>
<span class="sd">    either ``scipy`` or ``numpy`` functions if available, and Python&#39;s</span>
<span class="sd">    standard library ``math``, or ``mpmath`` functions otherwise.</span>

<span class="sd">    ``modules`` can be one of the following types</span>

<span class="sd">     - the strings ``&quot;math&quot;``, ``&quot;mpmath&quot;``, ``&quot;numpy&quot;``, ``&quot;numexpr&quot;``,</span>
<span class="sd">       ``&quot;scipy&quot;``, ``&quot;sympy&quot;``, or ``&quot;tensorflow&quot;``. This uses the</span>
<span class="sd">       corresponding printer and namespace mapping for that module.</span>
<span class="sd">     - a module (e.g., ``math``). This uses the global namespace of the</span>
<span class="sd">       module. If the module is one of the above known modules, it will also</span>
<span class="sd">       use the corresponding printer and namespace mapping (i.e.,</span>
<span class="sd">       ``modules=numpy`` is equivalent to ``modules=&quot;numpy&quot;``).</span>
<span class="sd">     - a dictionary that maps names of SymPy functions to arbitrary functions</span>
<span class="sd">       (e.g., ``{&#39;sin&#39;: custom_sin}``).</span>
<span class="sd">     - a list that contains a mix of the arguments above, with higher priority</span>
<span class="sd">       given to entries appearing first (e.g., to use the NumPy module but</span>
<span class="sd">       override the ``sin`` function with a custom version, you can use</span>
<span class="sd">       ``[{&#39;sin&#39;: custom_sin}, &#39;numpy&#39;]``).</span>

<span class="sd">    The ``dummify`` keyword argument controls whether or not the variables in</span>
<span class="sd">    the provided expression that are not valid Python identifiers are</span>
<span class="sd">    substituted with dummy symbols. This allows for undefined functions like</span>
<span class="sd">    ``Function(&#39;f&#39;)(t)`` to be supplied as arguments. By default, the</span>
<span class="sd">    variables are only dummified if they are not valid Python identifiers. Set</span>
<span class="sd">    ``dummify=True`` to replace all arguments with dummy symbols (if ``args``</span>
<span class="sd">    is not a string) - for example, to ensure that the arguments do not</span>
<span class="sd">    redefine any built-in names.</span>

<span class="sd">    .. _lambdify-how-it-works:</span>

<span class="sd">    How it works</span>
<span class="sd">    ============</span>

<span class="sd">    When using this function, it helps a great deal to have an idea of what it</span>
<span class="sd">    is doing. At its core, lambdify is nothing more than a namespace</span>
<span class="sd">    translation, on top of a special printer that makes some corner cases work</span>
<span class="sd">    properly.</span>

<span class="sd">    To understand lambdify, first we must properly understand how Python</span>
<span class="sd">    namespaces work. Say we had two files. One called ``sin_cos_sympy.py``,</span>
<span class="sd">    with</span>

<span class="sd">    .. code:: python</span>

<span class="sd">        # sin_cos_sympy.py</span>

<span class="sd">        from sympy import sin, cos</span>

<span class="sd">        def sin_cos(x):</span>
<span class="sd">            return sin(x) + cos(x)</span>


<span class="sd">    and one called ``sin_cos_numpy.py`` with</span>

<span class="sd">    .. code:: python</span>

<span class="sd">        # sin_cos_numpy.py</span>

<span class="sd">        from numpy import sin, cos</span>

<span class="sd">        def sin_cos(x):</span>
<span class="sd">            return sin(x) + cos(x)</span>

<span class="sd">    The two files define an identical function ``sin_cos``. However, in the</span>
<span class="sd">    first file, ``sin`` and ``cos`` are defined as the SymPy ``sin`` and</span>
<span class="sd">    ``cos``. In the second, they are defined as the NumPy versions.</span>

<span class="sd">    If we were to import the first file and use the ``sin_cos`` function, we</span>
<span class="sd">    would get something like</span>

<span class="sd">    &gt;&gt;&gt; from sin_cos_sympy import sin_cos # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; sin_cos(1) # doctest: +SKIP</span>
<span class="sd">    cos(1) + sin(1)</span>

<span class="sd">    On the other hand, if we imported ``sin_cos`` from the second file, we</span>
<span class="sd">    would get</span>

<span class="sd">    &gt;&gt;&gt; from sin_cos_numpy import sin_cos # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; sin_cos(1) # doctest: +SKIP</span>
<span class="sd">    1.38177329068</span>

<span class="sd">    In the first case we got a symbolic output, because it used the symbolic</span>
<span class="sd">    ``sin`` and ``cos`` functions from SymPy. In the second, we got a numeric</span>
<span class="sd">    result, because ``sin_cos`` used the numeric ``sin`` and ``cos`` functions</span>
<span class="sd">    from NumPy. But notice that the versions of ``sin`` and ``cos`` that were</span>
<span class="sd">    used was not inherent to the ``sin_cos`` function definition. Both</span>
<span class="sd">    ``sin_cos`` definitions are exactly the same. Rather, it was based on the</span>
<span class="sd">    names defined at the module where the ``sin_cos`` function was defined.</span>

<span class="sd">    The key point here is that when function in Python references a name that</span>
<span class="sd">    is not defined in the function, that name is looked up in the &quot;global&quot;</span>
<span class="sd">    namespace of the module where that function is defined.</span>

<span class="sd">    Now, in Python, we can emulate this behavior without actually writing a</span>
<span class="sd">    file to disk using the ``exec`` function. ``exec`` takes a string</span>
<span class="sd">    containing a block of Python code, and a dictionary that should contain</span>
<span class="sd">    the global variables of the module. It then executes the code &quot;in&quot; that</span>
<span class="sd">    dictionary, as if it were the module globals. The following is equivalent</span>
<span class="sd">    to the ``sin_cos`` defined in ``sin_cos_sympy.py``:</span>

<span class="sd">    &gt;&gt;&gt; import sympy</span>
<span class="sd">    &gt;&gt;&gt; module_dictionary = {&#39;sin&#39;: sympy.sin, &#39;cos&#39;: sympy.cos}</span>
<span class="sd">    &gt;&gt;&gt; exec(&#39;&#39;&#39;</span>
<span class="sd">    ... def sin_cos(x):</span>
<span class="sd">    ...     return sin(x) + cos(x)</span>
<span class="sd">    ... &#39;&#39;&#39;, module_dictionary)</span>
<span class="sd">    &gt;&gt;&gt; sin_cos = module_dictionary[&#39;sin_cos&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sin_cos(1)</span>
<span class="sd">    cos(1) + sin(1)</span>

<span class="sd">    and similarly with ``sin_cos_numpy``:</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; module_dictionary = {&#39;sin&#39;: numpy.sin, &#39;cos&#39;: numpy.cos}</span>
<span class="sd">    &gt;&gt;&gt; exec(&#39;&#39;&#39;</span>
<span class="sd">    ... def sin_cos(x):</span>
<span class="sd">    ...     return sin(x) + cos(x)</span>
<span class="sd">    ... &#39;&#39;&#39;, module_dictionary)</span>
<span class="sd">    &gt;&gt;&gt; sin_cos = module_dictionary[&#39;sin_cos&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sin_cos(1)</span>
<span class="sd">    1.38177329068</span>

<span class="sd">    So now we can get an idea of how ``lambdify`` works. The name &quot;lambdify&quot;</span>
<span class="sd">    comes from the fact that we can think of something like ``lambdify(x,</span>
<span class="sd">    sin(x) + cos(x), &#39;numpy&#39;)`` as ``lambda x: sin(x) + cos(x)``, where</span>
<span class="sd">    ``sin`` and ``cos`` come from the ``numpy`` namespace. This is also why</span>
<span class="sd">    the symbols argument is first in ``lambdify``, as opposed to most SymPy</span>
<span class="sd">    functions where it comes after the expression: to better mimic the</span>
<span class="sd">    ``lambda`` keyword.</span>

<span class="sd">    ``lambdify`` takes the input expression (like ``sin(x) + cos(x)``) and</span>

<span class="sd">    1. Converts it to a string</span>
<span class="sd">    2. Creates a module globals dictionary based on the modules that are</span>
<span class="sd">       passed in (by default, it uses the NumPy module)</span>
<span class="sd">    3. Creates the string ``&quot;def func({vars}): return {expr}&quot;``, where ``{vars}`` is the</span>
<span class="sd">       list of variables separated by commas, and ``{expr}`` is the string</span>
<span class="sd">       created in step 1., then ``exec``s that string with the module globals</span>
<span class="sd">       namespace and returns ``func``.</span>

<span class="sd">    In fact, functions returned by ``lambdify`` support inspection. So you can</span>
<span class="sd">    see exactly how they are defined by using ``inspect.getsource``, or ``??`` if you</span>
<span class="sd">    are using IPython or the Jupyter notebook.</span>

<span class="sd">    &gt;&gt;&gt; f = lambdify(x, sin(x) + cos(x))</span>
<span class="sd">    &gt;&gt;&gt; import inspect</span>
<span class="sd">    &gt;&gt;&gt; print(inspect.getsource(f))</span>
<span class="sd">    def _lambdifygenerated(x):</span>
<span class="sd">        return (sin(x) + cos(x))</span>

<span class="sd">    This shows us the source code of the function, but not the namespace it</span>
<span class="sd">    was defined in. We can inspect that by looking at the ``__globals__``</span>
<span class="sd">    attribute of ``f``:</span>

<span class="sd">    &gt;&gt;&gt; f.__globals__[&#39;sin&#39;]</span>
<span class="sd">    &lt;ufunc &#39;sin&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f.__globals__[&#39;cos&#39;]</span>
<span class="sd">    &lt;ufunc &#39;cos&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f.__globals__[&#39;sin&#39;] is numpy.sin</span>
<span class="sd">    True</span>

<span class="sd">    This shows us that ``sin`` and ``cos`` in the namespace of ``f`` will be</span>
<span class="sd">    ``numpy.sin`` and ``numpy.cos``.</span>

<span class="sd">    Note that there are some convenience layers in each of these steps, but at</span>
<span class="sd">    the core, this is how ``lambdify`` works. Step 1 is done using the</span>
<span class="sd">    ``LambdaPrinter`` printers defined in the printing module (see</span>
<span class="sd">    :mod:`sympy.printing.lambdarepr`). This allows different SymPy expressions</span>
<span class="sd">    to define how they should be converted to a string for different modules.</span>
<span class="sd">    You can change which printer ``lambdify`` uses by passing a custom printer</span>
<span class="sd">    in to the ``printer`` argument.</span>

<span class="sd">    Step 2 is augmented by certain translations. There are default</span>
<span class="sd">    translations for each module, but you can provide your own by passing a</span>
<span class="sd">    list to the ``modules`` argument. For instance,</span>

<span class="sd">    &gt;&gt;&gt; def mysin(x):</span>
<span class="sd">    ...     print(&#39;taking the sin of&#39;, x)</span>
<span class="sd">    ...     return numpy.sin(x)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify(x, sin(x), [{&#39;sin&#39;: mysin}, &#39;numpy&#39;])</span>
<span class="sd">    &gt;&gt;&gt; f(1)</span>
<span class="sd">    taking the sin of 1</span>
<span class="sd">    0.8414709848078965</span>

<span class="sd">    The globals dictionary is generated from the list by merging the</span>
<span class="sd">    dictionary ``{&#39;sin&#39;: mysin}`` and the module dictionary for NumPy. The</span>
<span class="sd">    merging is done so that earlier items take precedence, which is why</span>
<span class="sd">    ``mysin`` is used above instead of ``numpy.sin``.</span>

<span class="sd">    If you want to modify the way ``lambdify`` works for a given function, it</span>
<span class="sd">    is usually easiest to do so by modifying the globals dictionary as such.</span>
<span class="sd">    In more complicated cases, it may be necessary to create and pass in a</span>
<span class="sd">    custom printer.</span>

<span class="sd">    Finally, step 3 is augmented with certain convenience operations, such as</span>
<span class="sd">    the addition of a docstring.</span>

<span class="sd">    Understanding how ``lambdify`` works can make it easier to avoid certain</span>
<span class="sd">    gotchas when using it. For instance, a common mistake is to create a</span>
<span class="sd">    lambdified function for one module (say, NumPy), and pass it objects from</span>
<span class="sd">    another (say, a SymPy expression).</span>

<span class="sd">    For instance, say we create</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify(x, x + 1, &#39;numpy&#39;)</span>

<span class="sd">    Now if we pass in a NumPy array, we get that array plus 1</span>

<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; a = numpy.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; f(a)</span>
<span class="sd">    [2 3]</span>

<span class="sd">    But what happens if you make the mistake of passing in a SymPy expression</span>
<span class="sd">    instead of a NumPy array:</span>

<span class="sd">    &gt;&gt;&gt; f(x + 1)</span>
<span class="sd">    x + 2</span>

<span class="sd">    This worked, but it was only by accident. Now take a different lambdified</span>
<span class="sd">    function:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sin</span>
<span class="sd">    &gt;&gt;&gt; g = lambdify(x, x + sin(x), &#39;numpy&#39;)</span>

<span class="sd">    This works as expected on NumPy arrays:</span>

<span class="sd">    &gt;&gt;&gt; g(a)</span>
<span class="sd">    [1.84147098 2.90929743]</span>

<span class="sd">    But if we try to pass in a SymPy expression, it fails</span>

<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     g(x + 1)</span>
<span class="sd">    ... # NumPy release after 1.17 raises TypeError instead of</span>
<span class="sd">    ... # AttributeError</span>
<span class="sd">    ... except (AttributeError, TypeError):</span>
<span class="sd">    ...     raise AttributeError() # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AttributeError:</span>

<span class="sd">    Now, let&#39;s look at what happened. The reason this fails is that ``g``</span>
<span class="sd">    calls ``numpy.sin`` on the input expression, and ``numpy.sin`` does not</span>
<span class="sd">    know how to operate on a SymPy object. **As a general rule, NumPy</span>
<span class="sd">    functions do not know how to operate on SymPy expressions, and SymPy</span>
<span class="sd">    functions do not know how to operate on NumPy arrays. This is why lambdify</span>
<span class="sd">    exists: to provide a bridge between SymPy and NumPy.**</span>

<span class="sd">    However, why is it that ``f`` did work? That&#39;s because ``f`` doesn&#39;t call</span>
<span class="sd">    any functions, it only adds 1. So the resulting function that is created,</span>
<span class="sd">    ``def _lambdifygenerated(x): return x + 1`` does not depend on the globals</span>
<span class="sd">    namespace it is defined in. Thus it works, but only by accident. A future</span>
<span class="sd">    version of ``lambdify`` may remove this behavior.</span>

<span class="sd">    Be aware that certain implementation details described here may change in</span>
<span class="sd">    future versions of SymPy. The API of passing in custom modules and</span>
<span class="sd">    printers will not change, but the details of how a lambda function is</span>
<span class="sd">    created may change. However, the basic idea will remain the same, and</span>
<span class="sd">    understanding it will be helpful to understanding the behavior of</span>
<span class="sd">    lambdify.</span>

<span class="sd">    **In general: you should create lambdified functions for one module (say,</span>
<span class="sd">    NumPy), and only pass it input types that are compatible with that module</span>
<span class="sd">    (say, NumPy arrays).** Remember that by default, if the ``module``</span>
<span class="sd">    argument is not provided, ``lambdify`` creates functions using the NumPy</span>
<span class="sd">    and SciPy namespaces.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.utilities.lambdify import implemented_function</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt, sin, Matrix</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import w, x, y, z</span>

<span class="sd">    &gt;&gt;&gt; f = lambdify(x, x**2)</span>
<span class="sd">    &gt;&gt;&gt; f(2)</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify((x, y, z), [z, y, x])</span>
<span class="sd">    &gt;&gt;&gt; f(1,2,3)</span>
<span class="sd">    [3, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify(x, sqrt(x))</span>
<span class="sd">    &gt;&gt;&gt; f(4)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify((x, y), sin(x*y)**2)</span>
<span class="sd">    &gt;&gt;&gt; f(0, 5)</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; row = lambdify((x, y), Matrix((x, x + y)).T, modules=&#39;sympy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; row(1, 2)</span>
<span class="sd">    Matrix([[1, 3]])</span>

<span class="sd">    ``lambdify`` can be used to translate SymPy expressions into mpmath</span>
<span class="sd">    functions. This may be preferable to using ``evalf`` (which uses mpmath on</span>
<span class="sd">    the backend) in some cases.</span>

<span class="sd">    &gt;&gt;&gt; import mpmath</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify(x, sin(x), &#39;mpmath&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f(1)</span>
<span class="sd">    0.8414709848078965</span>

<span class="sd">    Tuple arguments are handled and the lambdified function should</span>
<span class="sd">    be called with the same type of arguments as were used to create</span>
<span class="sd">    the function:</span>

<span class="sd">    &gt;&gt;&gt; f = lambdify((x, (y, z)), x + y)</span>
<span class="sd">    &gt;&gt;&gt; f(1, (2, 4))</span>
<span class="sd">    3</span>

<span class="sd">    The ``flatten`` function can be used to always work with flattened</span>
<span class="sd">    arguments:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.utilities.iterables import flatten</span>
<span class="sd">    &gt;&gt;&gt; args = w, (x, (y, z))</span>
<span class="sd">    &gt;&gt;&gt; vals = 1, (2, (3, 4))</span>
<span class="sd">    &gt;&gt;&gt; f = lambdify(flatten(args), w + x + y + z)</span>
<span class="sd">    &gt;&gt;&gt; f(*flatten(vals))</span>
<span class="sd">    10</span>

<span class="sd">    Functions present in ``expr`` can also carry their own numerical</span>
<span class="sd">    implementations, in a callable attached to the ``_imp_`` attribute. This</span>
<span class="sd">    can be used with undefined functions using the ``implemented_function``</span>
<span class="sd">    factory:</span>

<span class="sd">    &gt;&gt;&gt; f = implemented_function(Function(&#39;f&#39;), lambda x: x+1)</span>
<span class="sd">    &gt;&gt;&gt; func = lambdify(x, f(x))</span>
<span class="sd">    &gt;&gt;&gt; func(4)</span>
<span class="sd">    5</span>

<span class="sd">    ``lambdify`` always prefers ``_imp_`` implementations to implementations</span>
<span class="sd">    in other namespaces, unless the ``use_imps`` input parameter is False.</span>

<span class="sd">    Usage with Tensorflow:</span>

<span class="sd">    &gt;&gt;&gt; import tensorflow as tf</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Max, sin</span>
<span class="sd">    &gt;&gt;&gt; f = Max(x, sin(x))</span>
<span class="sd">    &gt;&gt;&gt; func = lambdify(x, f, &#39;tensorflow&#39;)</span>
<span class="sd">    &gt;&gt;&gt; result = func(tf.constant(1.0))</span>
<span class="sd">    &gt;&gt;&gt; print(result) # a tf.Tensor representing the result of the calculation</span>
<span class="sd">    Tensor(&quot;Maximum:0&quot;, shape=(), dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; sess = tf.Session()</span>
<span class="sd">    &gt;&gt;&gt; sess.run(result) # compute result</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; var = tf.Variable(1.0)</span>
<span class="sd">    &gt;&gt;&gt; sess.run(tf.global_variables_initializer())</span>
<span class="sd">    &gt;&gt;&gt; sess.run(func(var)) # also works for tf.Variable and tf.Placeholder</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]]) # works with any shape tensor</span>
<span class="sd">    &gt;&gt;&gt; sess.run(func(tensor))</span>
<span class="sd">    [[1. 2.]</span>
<span class="sd">     [3. 4.]]</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    - For functions involving large array calculations, numexpr can provide a</span>
<span class="sd">      significant speedup over numpy. Please note that the available functions</span>
<span class="sd">      for numexpr are more limited than numpy but can be expanded with</span>
<span class="sd">      ``implemented_function`` and user defined subclasses of Function. If</span>
<span class="sd">      specified, numexpr may be the only option in modules. The official list</span>
<span class="sd">      of numexpr functions can be found at:</span>
<span class="sd">      https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions</span>

<span class="sd">    - In previous versions of SymPy, ``lambdify`` replaced ``Matrix`` with</span>
<span class="sd">      ``numpy.matrix`` by default. As of SymPy 1.0 ``numpy.array`` is the</span>
<span class="sd">      default. To get the old default behavior you must pass in</span>
<span class="sd">      ``[{&#39;ImmutableDenseMatrix&#39;:  numpy.matrix}, &#39;numpy&#39;]`` to the</span>
<span class="sd">      ``modules`` kwarg.</span>

<span class="sd">      &gt;&gt;&gt; from sympy import lambdify, Matrix</span>
<span class="sd">      &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">      &gt;&gt;&gt; import numpy</span>
<span class="sd">      &gt;&gt;&gt; array2mat = [{&#39;ImmutableDenseMatrix&#39;: numpy.matrix}, &#39;numpy&#39;]</span>
<span class="sd">      &gt;&gt;&gt; f = lambdify((x, y), Matrix([x, y]), modules=array2mat)</span>
<span class="sd">      &gt;&gt;&gt; f(1, 2)</span>
<span class="sd">      [[1]</span>
<span class="sd">       [2]]</span>

<span class="sd">    - In the above examples, the generated functions can accept scalar</span>
<span class="sd">      values or numpy arrays as arguments.  However, in some cases</span>
<span class="sd">      the generated function relies on the input being a numpy array:</span>

<span class="sd">      &gt;&gt;&gt; from sympy import Piecewise</span>
<span class="sd">      &gt;&gt;&gt; from sympy.utilities.pytest import ignore_warnings</span>
<span class="sd">      &gt;&gt;&gt; f = lambdify(x, Piecewise((x, x &lt;= 1), (1/x, x &gt; 1)), &quot;numpy&quot;)</span>

<span class="sd">      &gt;&gt;&gt; with ignore_warnings(RuntimeWarning):</span>
<span class="sd">      ...     f(numpy.array([-1, 0, 1, 2]))</span>
<span class="sd">      [-1.   0.   1.   0.5]</span>

<span class="sd">      &gt;&gt;&gt; f(0)</span>
<span class="sd">      Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">      ZeroDivisionError: division by zero</span>

<span class="sd">      In such cases, the input should be wrapped in a numpy array:</span>

<span class="sd">      &gt;&gt;&gt; with ignore_warnings(RuntimeWarning):</span>
<span class="sd">      ...     float(f(numpy.array([0])))</span>
<span class="sd">      0.0</span>

<span class="sd">      Or if numpy functionality is not required another module can be used:</span>

<span class="sd">      &gt;&gt;&gt; f = lambdify(x, Piecewise((x, x &lt;= 1), (1/x, x &gt; 1)), &quot;math&quot;)</span>
<span class="sd">      &gt;&gt;&gt; f(0)</span>
<span class="sd">      0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="k">import</span> <span class="n">Symbol</span>

    <span class="c1"># If the user hasn&#39;t specified any modules, use what is available.</span>
    <span class="k">if</span> <span class="n">modules</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_import</span><span class="p">(</span><span class="s2">&quot;scipy&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_import</span><span class="p">(</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="c1"># Use either numpy (if available) or python.math where possible.</span>
                <span class="c1"># XXX: This leads to different behaviour on different systems and</span>
                <span class="c1">#      might be the reason for irreproducible errors.</span>
                <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;math&quot;</span><span class="p">,</span> <span class="s2">&quot;mpmath&quot;</span><span class="p">,</span> <span class="s2">&quot;sympy&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;numpy&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;scipy&quot;</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">]</span>

    <span class="c1"># Get the needed namespaces.</span>
    <span class="n">namespaces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># First find any function implementations</span>
    <span class="k">if</span> <span class="n">use_imps</span><span class="p">:</span>
        <span class="n">namespaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_imp_namespace</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="c1"># Check for dict before iterating</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modules</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">string_types</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">modules</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
        <span class="n">namespaces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">modules</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># consistency check</span>
        <span class="k">if</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;numexpr&#39;</span><span class="p">,</span> <span class="n">modules</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">modules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;numexpr must be the only item in &#39;modules&#39;&quot;</span><span class="p">)</span>
        <span class="n">namespaces</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">modules</span><span class="p">)</span>
    <span class="c1"># fill namespace with first having highest priority</span>
    <span class="n">namespace</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">namespaces</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">_get_namespace</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">&quot;atoms&quot;</span><span class="p">):</span>
        <span class="c1">#Try if you can extract symbols from the expression.</span>
        <span class="c1">#Move on if expr.atoms in not implemented.</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">str</span><span class="p">(</span><span class="n">term</span><span class="p">):</span> <span class="n">term</span><span class="p">})</span>

    <span class="k">if</span> <span class="n">printer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;mpmath&#39;</span><span class="p">,</span> <span class="n">namespaces</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.pycode</span> <span class="k">import</span> <span class="n">MpmathPrinter</span> <span class="k">as</span> <span class="n">Printer</span>
        <span class="k">elif</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;scipy&#39;</span><span class="p">,</span> <span class="n">namespaces</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.pycode</span> <span class="k">import</span> <span class="n">SciPyPrinter</span> <span class="k">as</span> <span class="n">Printer</span>
        <span class="k">elif</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">namespaces</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.pycode</span> <span class="k">import</span> <span class="n">NumPyPrinter</span> <span class="k">as</span> <span class="n">Printer</span>
        <span class="k">elif</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;numexpr&#39;</span><span class="p">,</span> <span class="n">namespaces</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.lambdarepr</span> <span class="k">import</span> <span class="n">NumExprPrinter</span> <span class="k">as</span> <span class="n">Printer</span>
        <span class="k">elif</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;tensorflow&#39;</span><span class="p">,</span> <span class="n">namespaces</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.tensorflow</span> <span class="k">import</span> <span class="n">TensorflowPrinter</span> <span class="k">as</span> <span class="n">Printer</span>
        <span class="k">elif</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;sympy&#39;</span><span class="p">,</span> <span class="n">namespaces</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.pycode</span> <span class="k">import</span> <span class="n">SymPyPrinter</span> <span class="k">as</span> <span class="n">Printer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.printing.pycode</span> <span class="k">import</span> <span class="n">PythonCodePrinter</span> <span class="k">as</span> <span class="n">Printer</span>
        <span class="n">user_functions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">namespaces</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">user_functions</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">printer</span> <span class="o">=</span> <span class="n">Printer</span><span class="p">({</span><span class="s1">&#39;fully_qualified_modules&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;inline&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="s1">&#39;allow_unknown_functions&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                           <span class="s1">&#39;user_functions&#39;</span><span class="p">:</span> <span class="n">user_functions</span><span class="p">})</span>

    <span class="c1"># Get the names of the args, for creating a docstring</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Grab the callers frame, for getting the names by inspection (if needed)</span>
    <span class="n">callers_local_vars</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_locals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># It&#39;s an iterable. Try to get name by inspection of calling frame.</span>
            <span class="n">name_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">var_name</span> <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">var_val</span> <span class="ow">in</span> <span class="n">callers_local_vars</span>
                    <span class="k">if</span> <span class="n">var_val</span> <span class="ow">is</span> <span class="n">var</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Cannot infer name with certainty. arg_# will have to do.</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;arg_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="c1"># Create the function definition code and execute it</span>
    <span class="n">funcname</span> <span class="o">=</span> <span class="s1">&#39;_lambdifygenerated&#39;</span>
    <span class="k">if</span> <span class="n">_module_present</span><span class="p">(</span><span class="s1">&#39;tensorflow&#39;</span><span class="p">,</span> <span class="n">namespaces</span><span class="p">):</span>
        <span class="n">funcprinter</span> <span class="o">=</span> <span class="n">_TensorflowEvaluatorPrinter</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">dummify</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">funcprinter</span> <span class="o">=</span> <span class="n">_EvaluatorPrinter</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">dummify</span><span class="p">)</span>
    <span class="n">funcstr</span> <span class="o">=</span> <span class="n">funcprinter</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

    <span class="c1"># Collect the module imports from the code printers.</span>
    <span class="n">imp_mod_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">mod</span><span class="p">,</span> <span class="n">keys</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="s1">&#39;module_imports&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">namespace</span><span class="p">:</span>
                <span class="n">imp_mod_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;from </span><span class="si">%s</span><span class="s2"> import </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">imp_mod_lines</span><span class="p">:</span>
        <span class="n">exec_</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="p">{},</span> <span class="n">namespace</span><span class="p">)</span>

    <span class="c1"># Provide lambda expression with builtins, and compatible implementation of range</span>
    <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;builtins&#39;</span><span class="p">:</span><span class="n">builtins</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span><span class="nb">range</span><span class="p">})</span>

    <span class="n">funclocals</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">global</span> <span class="n">_lambdify_generated_counter</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;&lt;lambdifygenerated-</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="n">_lambdify_generated_counter</span>
    <span class="n">_lambdify_generated_counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">funcstr</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">)</span>
    <span class="n">exec_</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">funclocals</span><span class="p">)</span>
    <span class="c1"># mtime has to be None or else linecache.checkcache will remove it</span>
    <span class="n">linecache</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">funcstr</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">funcstr</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span> <span class="n">filename</span><span class="p">)</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">funclocals</span><span class="p">[</span><span class="n">funcname</span><span class="p">]</span>

    <span class="c1"># Apply the docstring</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="s2">&quot;func(</span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">names</span><span class="p">))</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">subsequent_indent</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">expr_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">78</span><span class="p">:</span>
        <span class="n">expr_str</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">expr_str</span><span class="p">,</span> <span class="mi">75</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
    <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Created with lambdify. Signature:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="si">{sig}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Expression:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="si">{expr}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Source code:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="si">{src}</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Imported modules:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="si">{imp_mods}</span><span class="s2">&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sig</span><span class="o">=</span><span class="n">sig</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr_str</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">funcstr</span><span class="p">,</span> <span class="n">imp_mods</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">imp_mod_lines</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">func</span></div>

<span class="k">def</span> <span class="nf">_module_present</span><span class="p">(</span><span class="n">modname</span><span class="p">,</span> <span class="n">modlist</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">modname</span> <span class="ow">in</span> <span class="n">modlist</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">modlist</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">modname</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">_get_namespace</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is used by _lambdify to parse its arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">_import</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MODULES</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">m</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;__dict__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Argument must be either a string, dict or module but it is: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">m</span><span class="p">)</span>

<div class="viewcode-block" id="lambdastr"><a class="viewcode-back" href="../../../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdastr">[docs]</a><span class="k">def</span> <span class="nf">lambdastr</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">printer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dummify</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a string that can be evaluated to a lambda function.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy.utilities.lambdify import lambdastr</span>
<span class="sd">    &gt;&gt;&gt; lambdastr(x, x**2)</span>
<span class="sd">    &#39;lambda x: (x**2)&#39;</span>
<span class="sd">    &gt;&gt;&gt; lambdastr((x,y,z), [z,y,x])</span>
<span class="sd">    &#39;lambda x,y,z: ([z, y, x])&#39;</span>

<span class="sd">    Although tuples may not appear as arguments to lambda in Python 3,</span>
<span class="sd">    lambdastr will create a lambda function that will unpack the original</span>
<span class="sd">    arguments so that nested arguments can be handled:</span>

<span class="sd">    &gt;&gt;&gt; lambdastr((x, (y, z)), x + y)</span>
<span class="sd">    &#39;lambda _0,_1: (lambda x,y,z: (x + y))(_0,_1[0],_1[1])&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Transforming everything to strings.</span>
    <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">DeferredVector</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">Basic</span>

    <span class="k">if</span> <span class="n">printer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">printer</span><span class="p">):</span>
            <span class="n">lambdarepr</span> <span class="o">=</span> <span class="n">printer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">printer</span><span class="p">):</span>
                <span class="n">lambdarepr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">printer</span><span class="p">()</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lambdarepr</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">printer</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#XXX: This has to be done here because of circular imports</span>
        <span class="kn">from</span> <span class="nn">sympy.printing.lambdarepr</span> <span class="k">import</span> <span class="n">lambdarepr</span>

    <span class="k">def</span> <span class="nf">sub_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dummies_dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">args</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">DeferredVector</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">dummies</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">sub_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
            <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">dummies</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># replace these with Dummy symbols</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">)):</span>
                <span class="n">dummies</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
                <span class="n">dummies_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">args</span> <span class="p">:</span> <span class="n">dummies</span><span class="p">})</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">dummies</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sub_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">dummies_dict</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">dummies_dict</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">DeferredVector</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_expr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_expr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sub_expr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_expr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Transform args</span>
    <span class="k">def</span> <span class="nf">isiter</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">iterable</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">DeferredVector</span><span class="p">,</span> <span class="n">NotIterable</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">flat_indexes</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isiter</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ndeep</span> <span class="ow">in</span> <span class="n">flat_indexes</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ndeep</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span>

            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">dummify</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dummify</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">a</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">args</span> <span class="k">if</span> <span class="n">isiter</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">args</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">isiter</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">isiter</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">dum_args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">Dummy</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))]</span>

        <span class="n">indexed_args</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="n">dum_args</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
                    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">flat_indexes</span><span class="p">(</span><span class="n">args</span><span class="p">)])</span>

        <span class="n">lstr</span> <span class="o">=</span> <span class="n">lambdastr</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">expr</span><span class="p">,</span> <span class="n">printer</span><span class="o">=</span><span class="n">printer</span><span class="p">,</span> <span class="n">dummify</span><span class="o">=</span><span class="n">dummify</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;lambda </span><span class="si">%s</span><span class="s1">: (</span><span class="si">%s</span><span class="s1">)(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dum_args</span><span class="p">),</span> <span class="n">lstr</span><span class="p">,</span> <span class="n">indexed_args</span><span class="p">)</span>

    <span class="n">dummies_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">dummify</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">sub_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dummies_dict</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">DeferredVector</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

    <span class="c1"># Transform expr</span>
    <span class="k">if</span> <span class="n">dummify</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">sub_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">dummies_dict</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">lambdarepr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;lambda </span><span class="si">%s</span><span class="s2">: (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span></div>

<span class="k">class</span> <span class="nc">_EvaluatorPrinter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dummify</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dummify</span> <span class="o">=</span> <span class="n">dummify</span>

        <span class="c1">#XXX: This has to be done here because of circular imports</span>
        <span class="kn">from</span> <span class="nn">sympy.printing.lambdarepr</span> <span class="k">import</span> <span class="n">LambdaPrinter</span>

        <span class="k">if</span> <span class="n">printer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">printer</span> <span class="o">=</span> <span class="n">LambdaPrinter</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">printer</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exprrepr</span> <span class="o">=</span> <span class="n">printer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">printer</span><span class="p">):</span>
                <span class="n">printer</span> <span class="o">=</span> <span class="n">printer</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_exprrepr</span> <span class="o">=</span> <span class="n">printer</span><span class="o">.</span><span class="n">doprint</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="s1">&#39;_print_Symbol&#39;</span><span class="p">):</span>
                <span class="n">symbolrepr</span> <span class="o">=</span> <span class="n">printer</span><span class="o">.</span><span class="n">_print_Symbol</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="s1">&#39;_print_Dummy&#39;</span><span class="p">):</span>
                <span class="n">dummyrepr</span> <span class="o">=</span> <span class="n">printer</span><span class="o">.</span><span class="n">_print_Dummy</span>

        <span class="c1"># Used to print the generated function arguments in a standard way</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_argrepr</span> <span class="o">=</span> <span class="n">LambdaPrinter</span><span class="p">()</span><span class="o">.</span><span class="n">doprint</span>

    <span class="k">def</span> <span class="nf">doprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the function definition code as a string.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span>

        <span class="n">funcbody</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span>

        <span class="n">argstrs</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

        <span class="c1"># Generate argument unpacking and final argument list</span>
        <span class="n">funcargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unpackings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">argstr</span> <span class="ow">in</span> <span class="n">argstrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">argstr</span><span class="p">):</span>
                <span class="n">funcargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_argrepr</span><span class="p">(</span><span class="n">Dummy</span><span class="p">()))</span>
                <span class="n">unpackings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_print_unpacking</span><span class="p">(</span><span class="n">argstr</span><span class="p">,</span> <span class="n">funcargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">funcargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">argstr</span><span class="p">)</span>

        <span class="n">funcsig</span> <span class="o">=</span> <span class="s1">&#39;def </span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">):&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">funcargs</span><span class="p">))</span>

        <span class="c1"># Wrap input arguments before unpacking</span>
        <span class="n">funcbody</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_print_funcargwrapping</span><span class="p">(</span><span class="n">funcargs</span><span class="p">))</span>

        <span class="n">funcbody</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unpackings</span><span class="p">)</span>

        <span class="n">funcbody</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;return (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exprrepr</span><span class="p">(</span><span class="n">expr</span><span class="p">)))</span>

        <span class="n">funclines</span> <span class="o">=</span> <span class="p">[</span><span class="n">funcsig</span><span class="p">]</span>
        <span class="n">funclines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39;    &#39;</span> <span class="o">+</span> <span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">funcbody</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">funclines</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">_is_safe_ident</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ident</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">()</span> \
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">keyword</span><span class="o">.</span><span class="n">iskeyword</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_safe_ident_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^[a-zA-Z_][a-zA-Z0-9_]*$&#39;</span><span class="p">)</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">_is_safe_ident</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_safe_ident_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">keyword</span><span class="o">.</span><span class="n">iskeyword</span><span class="p">(</span><span class="n">ident</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ident</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Preprocess args, expr to replace arguments that do not map</span>
<span class="sd">        to valid Python identifiers.</span>

<span class="sd">        Returns string form of args, and updated expr.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">Basic</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">DeferredVector</span>
        <span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="k">import</span> <span class="n">_uniquely_named_symbol</span>
        <span class="kn">from</span> <span class="nn">sympy.core.expr</span> <span class="k">import</span> <span class="n">Expr</span>

        <span class="c1"># Args of type Dummy can cause name collisions with args</span>
        <span class="c1"># of type Symbol.  Force dummify of everything in this</span>
        <span class="c1"># situation.</span>
        <span class="n">dummify</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dummify</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">flatten</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

        <span class="n">argstrs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))))):</span>
            <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">DeferredVector</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_symbol</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argrepr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dummify</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_safe_ident</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">dummy</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
                        <span class="n">dummy</span> <span class="o">=</span> <span class="n">_uniquely_named_symbol</span><span class="p">(</span><span class="n">dummy</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argrepr</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subexpr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="n">dummy</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">dummify</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">)):</span>
                <span class="n">dummy</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argrepr</span><span class="p">(</span><span class="n">dummy</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subexpr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{</span><span class="n">arg</span><span class="p">:</span> <span class="n">dummy</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">argstrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">argstrs</span><span class="p">,</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">_subexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">dummies_dict</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="k">import</span> <span class="n">DeferredVector</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sympify</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">xreplace</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;xreplace&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xreplace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">xreplace</span><span class="p">(</span><span class="n">dummies_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">DeferredVector</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subexpr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subexpr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subexpr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subexpr</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dummies_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">_print_funcargwrapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate argument wrapping code.</span>

<span class="sd">        args is the argument list of the generated function (strings).</span>

<span class="sd">        Return value is a list of lines of code that will be inserted  at</span>
<span class="sd">        the beginning of the function definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_print_unpacking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unpackto</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate argument unpacking code.</span>

<span class="sd">        arg is the function argument to be unpacked (a string), and</span>
<span class="sd">        unpackto is a list or nested lists of the variable names (strings) to</span>
<span class="sd">        unpack to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">unpack_lhs</span><span class="p">(</span><span class="n">lvalues</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">unpack_lhs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">else</span> <span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">lvalues</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unpack_lhs</span><span class="p">(</span><span class="n">unpackto</span><span class="p">),</span> <span class="n">arg</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">_TensorflowEvaluatorPrinter</span><span class="p">(</span><span class="n">_EvaluatorPrinter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_print_unpacking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lvalues</span><span class="p">,</span> <span class="n">rvalue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate argument unpacking code.</span>

<span class="sd">        This method is used when the input value is not interable,</span>
<span class="sd">        but can be indexed (see issue #14655).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">flatten</span>

        <span class="k">def</span> <span class="nf">flat_indexes</span><span class="p">(</span><span class="n">elems</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ndeep</span> <span class="ow">in</span> <span class="n">flat_indexes</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ndeep</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span>

                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">indexed</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rvalue</span><span class="p">,</span> <span class="s1">&#39;][&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">ind</span><span class="p">)))</span>
                                <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">flat_indexes</span><span class="p">(</span><span class="n">lvalues</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">] = [</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">lvalues</span><span class="p">)),</span> <span class="n">indexed</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">_imp_namespace</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return namespace dict with function implementations</span>

<span class="sd">    We need to search for functions in anything that can be thrown at</span>
<span class="sd">    us - that is - anything that could be passed as ``expr``.  Examples</span>
<span class="sd">    include sympy expressions, as well as tuples, lists and dicts that may</span>
<span class="sd">    contain sympy expressions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr : object</span>
<span class="sd">       Something passed to lambdify, that will generate valid code from</span>
<span class="sd">       ``str(expr)``.</span>
<span class="sd">    namespace : None or mapping</span>
<span class="sd">       Namespace to fill.  None results in new empty dict</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    namespace : dict</span>
<span class="sd">       dict with keys of implemented function names within ``expr`` and</span>
<span class="sd">       corresponding values being the numerical implementation of</span>
<span class="sd">       function</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; from sympy.utilities.lambdify import implemented_function, _imp_namespace</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Function</span>
<span class="sd">    &gt;&gt;&gt; f = implemented_function(Function(&#39;f&#39;), lambda x: x+1)</span>
<span class="sd">    &gt;&gt;&gt; g = implemented_function(Function(&#39;g&#39;), lambda x: x*10)</span>
<span class="sd">    &gt;&gt;&gt; namespace = _imp_namespace(f(g(x)))</span>
<span class="sd">    &gt;&gt;&gt; sorted(namespace.keys())</span>
<span class="sd">    [&#39;f&#39;, &#39;g&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Delayed import to avoid circular imports</span>
    <span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">FunctionClass</span>
    <span class="k">if</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># tuples, lists, dicts are valid expressions</span>
    <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
            <span class="n">_imp_namespace</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">namespace</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># functions can be in dictionary keys</span>
            <span class="n">_imp_namespace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
            <span class="n">_imp_namespace</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">namespace</span>
    <span class="c1"># sympy expressions may be Functions themselves</span>
    <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">FunctionClass</span><span class="p">):</span>
        <span class="n">imp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;_imp_&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">imp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="ow">and</span> <span class="n">namespace</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">!=</span> <span class="n">imp</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;We found more than one &#39;</span>
                                 <span class="s1">&#39;implementation with name &#39;</span>
                                 <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">namespace</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">imp</span>
    <span class="c1"># and / or they may take Functions as arguments</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;args&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">_imp_namespace</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">namespace</span>


<div class="viewcode-block" id="implemented_function"><a class="viewcode-back" href="../../../modules/utilities/lambdify.html#sympy.utilities.lambdify.implemented_function">[docs]</a><span class="k">def</span> <span class="nf">implemented_function</span><span class="p">(</span><span class="n">symfunc</span><span class="p">,</span> <span class="n">implementation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Add numerical ``implementation`` to function ``symfunc``.</span>

<span class="sd">    ``symfunc`` can be an ``UndefinedFunction`` instance, or a name string.</span>
<span class="sd">    In the latter case we create an ``UndefinedFunction`` instance with that</span>
<span class="sd">    name.</span>

<span class="sd">    Be aware that this is a quick workaround, not a general method to create</span>
<span class="sd">    special symbolic functions. If you want to create a symbolic function to be</span>
<span class="sd">    used by all the machinery of SymPy you should subclass the ``Function``</span>
<span class="sd">    class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symfunc : ``str`` or ``UndefinedFunction`` instance</span>
<span class="sd">       If ``str``, then create new ``UndefinedFunction`` with this as</span>
<span class="sd">       name.  If ``symfunc`` is an Undefined function, create a new function</span>
<span class="sd">       with the same name and the implemented function attached.</span>
<span class="sd">    implementation : callable</span>
<span class="sd">       numerical implementation to be called by ``evalf()`` or ``lambdify``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    afunc : sympy.FunctionClass instance</span>
<span class="sd">       function with attached implementation</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; from sympy.utilities.lambdify import lambdify, implemented_function</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Function</span>
<span class="sd">    &gt;&gt;&gt; f = implemented_function(&#39;f&#39;, lambda x: x+1)</span>
<span class="sd">    &gt;&gt;&gt; lam_f = lambdify(x, f(x))</span>
<span class="sd">    &gt;&gt;&gt; lam_f(4)</span>
<span class="sd">    5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Delayed import to avoid circular imports</span>
    <span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="k">import</span> <span class="n">UndefinedFunction</span>
    <span class="c1"># if name, create function to hold implementation</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symfunc</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">symfunc</span><span class="o">.</span><span class="n">_kwargs</span>
        <span class="n">symfunc</span> <span class="o">=</span> <span class="n">symfunc</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symfunc</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="c1"># Keyword arguments to UndefinedFunction are added as attributes to</span>
        <span class="c1"># the created class.</span>
        <span class="n">symfunc</span> <span class="o">=</span> <span class="n">UndefinedFunction</span><span class="p">(</span>
            <span class="n">symfunc</span><span class="p">,</span> <span class="n">_imp_</span><span class="o">=</span><span class="nb">staticmethod</span><span class="p">(</span><span class="n">implementation</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symfunc</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            symfunc should be either a string or</span>
<span class="s1">            an UndefinedFunction instance.&#39;&#39;&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">symfunc</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.5.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019 SymPy Development Team.
      Last updated on Aug 08, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>